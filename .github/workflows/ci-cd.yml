name: CI/CD - Deploy to Production

on:
  push:
    branches:
      - master

env:
  JAVA_VERSION: '21'
  MAVEN_VERSION: '3.9.9'

jobs:
  # Step 1: Lint and Format Check
  lint:
    name: Lint and Format Check
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up JDK ${{ env.JAVA_VERSION }}
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'corretto'
          cache: 'maven'

      - name: Check code formatting
        run: mvn spotless:check || echo "No spotless plugin configured"
        continue-on-error: true

      - name: Run Maven validate
        run: mvn validate

  # Step 2: Run Tests with Coverage (after lint)
  test:
    name: Run Tests with Coverage
    runs-on: ubuntu-latest
    needs: [lint]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK ${{ env.JAVA_VERSION }}
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'corretto'
          cache: 'maven'

      - name: Run tests with coverage
        run: mvn clean test jacoco:report

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          file: ./target/site/jacoco/jacoco.xml
          flags: unittests
          name: codecov-production
          fail_ci_if_error: false

  # Step 3: Security Scan (parallel with tests)
  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: [lint]
    permissions:
      security-events: write
      contents: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK ${{ env.JAVA_VERSION }}
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'corretto'
          cache: 'maven'

      - name: Run OWASP Dependency Check
        run: mvn dependency-check:check || echo "No dependency-check configured"
        continue-on-error: true

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy results
        uses: github/codeql-action/upload-sarif@v4
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

  # Step 4: SonarCloud Analysis (after tests)
  sonarcloud:
    name: SonarCloud Analysis
    runs-on: ubuntu-latest
    needs: [test]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up JDK ${{ env.JAVA_VERSION }}
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'corretto'
          cache: 'maven'

      - name: Cache SonarCloud packages
        uses: actions/cache@v4
        with:
          path: ~/.sonar/cache
          key: ${{ runner.os }}-sonar
          restore-keys: ${{ runner.os }}-sonar

      - name: Build and analyze with SonarCloud
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: |
          mvn -B verify org.sonarsource.scanner.maven:sonar-maven-plugin:sonar \
            -Dsonar.projectKey=${{ secrets.SONAR_PROJECT_KEY }} \
            -Dsonar.organization=${{ secrets.SONAR_ORGANIZATION }} \
            -Dsonar.host.url=https://sonarcloud.io \
            -Dsonar.java.coveragePlugin=jacoco \
            -Dsonar.coverage.jacoco.xmlReportPaths=target/site/jacoco/jacoco.xml

  # Step 5: Build Application (after tests and security)
  build:
    name: Build Application
    runs-on: ubuntu-latest
    needs: [test, security-scan]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK ${{ env.JAVA_VERSION }}
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'corretto'
          cache: 'maven'

      - name: Build application
        run: mvn clean package -DskipTests

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: production-build
          path: |
            target/journal-index-integration-1.0.0.jar
            serverless.yml
            environments/
          retention-days: 7

  # Step 6: Deploy to Production (after all checks pass)
  deploy:
    name: Deploy to AWS Production
    runs-on: ubuntu-latest
    needs: [build, sonarcloud]
    environment:
      name: production
      url: https://console.aws.amazon.com/lambda
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK ${{ env.JAVA_VERSION }}
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'corretto'
          cache: 'maven'

      - name: Install Node.js (for Serverless Framework)
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Install Serverless Framework
        run: npm install -g serverless@4

      - name: Build application
        run: mvn clean package -DskipTests

      - name: Deploy to AWS
        env:
          # AWS & Serverless
          SERVERLESS_ACCESS_KEY: ${{ secrets.SERVERLESS_ACCESS_KEY }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          SERVERLESS_DEPLOYMENT_BUCKET: ${{ secrets.DEPLOYMENT_BUCKET_NAME }}
          S3_BUCKET_NAME: ${{ secrets.S3_BUCKET_NAME }}
          # Database
          DB_URL: ${{ secrets.DB_URL }}
          DB_USERNAME: ${{ secrets.DB_USERNAME }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          DB_NAME: ${{ secrets.DB_NAME }}
          # SQS
          SQS_QUEUE_ARN: ${{ secrets.SQS_QUEUE_ARN }}
          SQS_QUEUE_URL: ${{ secrets.SQS_QUEUE_URL }}
          # VPC Configuration
          VPC_ID: ${{ secrets.VPC_ID }}
          VPC_CIDR: ${{ secrets.VPC_CIDR }}
          VPC_SECURITY_GROUP_ID: ${{ secrets.VPC_SECURITY_GROUP_ID }}
          VPC_SUBNET_ID_1: ${{ secrets.VPC_SUBNET_ID_1 }}
          VPC_SUBNET_ID_2: ${{ secrets.VPC_SUBNET_ID_2 }}
          # MySQL Configuration
          MYSQL_PORT: "3306"
          MYSQL_DATABASE: ${{ secrets.DB_NAME }}
          MYSQL_SSL_MODE: "REQUIRED"
          MYSQL_CONNECTION_TIMEOUT: "30000"
          MYSQL_SOCKET_TIMEOUT: "30000"
        run: |
          # Extract MYSQL_HOST from DB_URL (jdbc:mysql://HOST:PORT/DATABASE)
          export MYSQL_HOST=$(echo "$DB_URL" | sed -n 's#.*://\([^:]*\):.*#\1#p')
          echo "üìù Extracted MYSQL_HOST: $MYSQL_HOST"
          
          echo "üîê Logging into Serverless Framework..."
          if [ -n "$SERVERLESS_ACCESS_KEY" ]; then
            echo "$SERVERLESS_ACCESS_KEY" | serverless login --key
          fi

          echo "üìã Checking CloudFormation stack status..."
          check_stack_status() {
            local stack_name="journal-index-integration-production"
            local status=$(aws cloudformation describe-stacks --stack-name $stack_name --region $AWS_REGION --query 'Stacks[0].StackStatus' --output text 2>/dev/null || echo "STACK_NOT_FOUND")
            echo $status
          }

          max_attempts=30
          attempt=1

          while [ $attempt -le $max_attempts ]; do
            status=$(check_stack_status)
            echo "Attempt $attempt/$max_attempts - Stack status: $status"

            case $status in
              "CREATE_COMPLETE"|"UPDATE_COMPLETE"|"UPDATE_ROLLBACK_COMPLETE"|"STACK_NOT_FOUND")
                echo "‚úÖ Stack is ready for deployment"
                break
                ;;
              "UPDATE_IN_PROGRESS"|"CREATE_IN_PROGRESS")
                echo "‚è≥ Stack updating, waiting 30 seconds..."
                sleep 30
                ;;
              *)
                echo "Stack state: $status - proceeding anyway"
                break
                ;;
            esac

            attempt=$((attempt + 1))
          done

          echo "üöÄ Starting deployment to production..."
          max_deploy_attempts=3
          deploy_attempt=1

          while [ $deploy_attempt -le $max_deploy_attempts ]; do
            echo "Deployment attempt $deploy_attempt/$max_deploy_attempts"

            # All environment variables are already set from GitHub secrets above
            # No need to source env file - use secrets directly

            if sls deploy --stage production --region $AWS_REGION --verbose; then
              echo "‚úÖ Deployment successful!"
              
              # Show deployment info
              echo ""
              echo "üìä Deployment Information:"
              sls info --stage production --region $AWS_REGION
              
              break
            else
              DEPLOY_EXIT_CODE=$?
              echo "‚ùå Deployment failed on attempt $deploy_attempt (exit code: $DEPLOY_EXIT_CODE)"

              if [ $deploy_attempt -lt $max_deploy_attempts ]; then
                echo "‚è≥ Waiting 60 seconds before retry..."
                sleep 60
              else
                echo "‚ùå All deployment attempts failed"
                echo "Checking CloudFormation stack for errors..."
                aws cloudformation describe-stack-events \
                  --stack-name journal-index-integration-production \
                  --region $AWS_REGION \
                  --max-items 10 \
                  --query 'StackEvents[?ResourceStatus==`CREATE_FAILED` || ResourceStatus==`UPDATE_FAILED`]' \
                  --output table || true
                exit 1
              fi
            fi

            deploy_attempt=$((deploy_attempt + 1))
          done

      - name: Verify Deployment
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
        run: |
          echo "üîç Verifying Lambda function..."
          FUNCTION_NAME="journal-index-integration-production-processor"
          
          # Check if function exists
          if aws lambda get-function \
            --function-name $FUNCTION_NAME \
            --region $AWS_REGION \
            --query 'Configuration.{Name:FunctionName,Runtime:Runtime,State:State,LastModified:LastModified}' \
            --output table; then
            echo "‚úÖ Lambda function verified successfully"
          else
            echo "‚ùå Lambda function verification failed"
            echo "Listing all Lambda functions with 'journal-index' in name:"
            aws lambda list-functions \
              --region $AWS_REGION \
              --query 'Functions[?contains(FunctionName, `journal-index`)].{Name:FunctionName,Runtime:Runtime,State:State}' \
              --output table
            exit 1
          fi

      - name: Deployment Summary
        run: |
          echo ""
          echo "üéâ Deployment Summary"
          echo "===================="
          echo "Environment: Production"
          echo "Region: ${{ secrets.AWS_REGION }}"
          echo "Function: journal-index-integration-production-processor"
          echo ""
          echo "‚úÖ Deployment completed successfully!"
          echo ""
          echo "üìä Useful Commands:"
          echo "View logs:"
          echo "  aws logs tail /aws/lambda/journal-index-integration-production-processor --follow"
          echo ""
          echo "Get function info:"
          echo "  serverless info --stage production"
          echo ""
          echo "Invoke function:"
          echo "  serverless invoke --function journalProcessor --stage production"

  # Summary Job
  deployment-complete:
    name: ‚úÖ Deployment Complete
    runs-on: ubuntu-latest
    needs: [deploy]
    if: always()
    
    steps:
      - name: Final Status
        run: |
          if [[ "${{ needs.deploy.result }}" == "success" ]]; then
            echo "üéâ Production deployment completed successfully!"
          else
            echo "‚ùå Production deployment failed!"
            exit 1
          fi
